Since your AKS cluster already exists, let's work with the existing cluster. Here's the step-by-step process:

Step 1: Get Your Existing AKS Cluster Information
bash
# List your AKS clusters to confirm the name
az aks list --output table

# Set your cluster details (replace with your actual values)
RESOURCE_GROUP="myResourceGroup"
CLUSTER_NAME="myAKSCluster"

# Get the node resource group (where AKS manages resources)
NODE_RESOURCE_GROUP=$(az aks show \
  --resource-group $RESOURCE_GROUP \
  --name $CLUSTER_NAME \
  --query nodeResourceGroup -o tsv)

echo "Node Resource Group: $NODE_RESOURCE_GROUP"

# Check if workload identity is enabled
az aks show \
  --resource-group $RESOURCE_GROUP \
  --name $CLUSTER_NAME \
  --query "oidcIssuerProfile.enabled"
Step 2: Enable Workload Identity on Existing AKS Cluster (if not enabled)
bash
# Enable OIDC issuer and Workload Identity on your existing cluster
az aks update \
  --resource-group $RESOURCE_GROUP \
  --name $CLUSTER_NAME \
  --enable-oidc-issuer \
  --enable-workload-identity

# Get the OIDC issuer URL (save this)
OIDC_ISSUER=$(az aks show \
  --resource-group $RESOURCE_GROUP \
  --name $CLUSTER_NAME \
  --query "oidcIssuerProfile.issuerUrl" -o tsv)

echo "OIDC Issuer URL: $OIDC_ISSUER"
Step 3: Create User-Assigned Managed Identity
bash
# Create managed identity in the node resource group
az identity create \
  --resource-group $NODE_RESOURCE_GROUP \
  --name myAppManagedIdentity

# Get identity details
IDENTITY_CLIENT_ID=$(az identity show \
  --resource-group $NODE_RESOURCE_GROUP \
  --name myAppManagedIdentity \
  --query clientId -o tsv)

IDENTITY_RESOURCE_ID=$(az identity show \
  --resource-group $NODE_RESOURCE_GROUP \
  --name myAppManagedIdentity \
  --query id -o tsv)

IDENTITY_PRINCIPAL_ID=$(az identity show \
  --resource-group $NODE_RESOURCE_GROUP \
  --name myAppManagedIdentity \
  --query principalId -o tsv)

# Save these values - you'll need them
echo "CLIENT_ID: $IDENTITY_CLIENT_ID"
echo "RESOURCE_ID: $IDENTITY_RESOURCE_ID" 
echo "PRINCIPAL_ID: $IDENTITY_PRINCIPAL_ID"
Step 4: Grant Key Vault Access to Managed Identity
bash
# Replace with your Key Vault name
KEY_VAULT_NAME="mykeyvault"

# Grant Key Vault access using access policy
az keyvault set-policy \
  --name $KEY_VAULT_NAME \
  --object-id $IDENTITY_PRINCIPAL_ID \
  --secret-permissions get list

# OR use RBAC (recommended for newer setups)
az role assignment create \
  --assignee $IDENTITY_PRINCIPAL_ID \
  --role "Key Vault Secrets User" \
  --scope "/subscriptions/$(az account show --query id -o tsv)/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.KeyVault/vaults/$KEY_VAULT_NAME"

# Verify access
echo "Verifying Key Vault access..."
az keyvault secret list --vault-name $KEY_VAULT_NAME --query "[].name" --output table
Step 5: Create Kubernetes Service Account
bash
# Connect to your AKS cluster
az aks get-credentials --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME

# Create namespace for your application
kubectl create namespace myapp

# Create service account with workload identity annotation
kubectl create serviceaccount workload-identity-sa --namespace myapp

# Annotate the service account with the managed identity client ID
kubectl annotate serviceaccount workload-identity-sa \
  --namespace myapp \
  azure.workload.identity/client-id=$IDENTITY_CLIENT_ID

# Verify service account creation
kubectl get serviceaccount workload-identity-sa -n myapp -o yaml
Step 6: Create Federated Identity Credential
bash
# Create federated identity credential to link K8s service account with managed identity
az identity federated-credential create \
  --name myAppFederatedCredential \
  --identity-name myAppManagedIdentity \
  --resource-group $NODE_RESOURCE_GROUP \
  --issuer $OIDC_ISSUER \
  --subject system:serviceaccount:myapp:workload-identity-sa

# Verify federated credential
az identity federated-credential show \
  --name myAppFederatedCredential \
  --identity-name myAppManagedIdentity \
  --resource-group $NODE_RESOURCE_GROUP
Step 7: Create Spring Boot Application
Create pom.xml:

xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>keyvault-demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>keyvault-demo</name>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>com.azure.spring</groupId>
            <artifactId>spring-cloud-azure-starter-keyvault-secrets</artifactId>
            <version>4.15.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
Create src/main/resources/application.yml:

yaml
spring:
  application:
    name: keyvault-demo-app
  cloud:
    azure:
      keyvault:
        secret:
          enabled: true
          endpoint: https://mykeyvault.vault.azure.net/  # Replace with your Key Vault name
          property-sources:
            - endpoint: https://mykeyvault.vault.azure.net/  # Replace with your Key Vault name
              name: mykeyvault  # Replace with your Key Vault name
      credential:
        managed-identity-enabled: true
        client-id: ${AZURE_CLIENT_ID}

server:
  port: 8080

logging:
  level:
    com.azure: DEBUG
    org.springframework.cloud.azure: DEBUG
Create src/main/java/com/example/keyvaultdemo/KeyVaultDemoApplication.java:

java
package com.example.keyvaultdemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.core.env.Environment;
import org.springframework.beans.factory.annotation.Autowired;

@SpringBootApplication
@RestController
public class KeyVaultDemoApplication {

    // Inject secrets from Key Vault
    @Value("${database-password:secret-not-found}")
    private String databasePassword;

    @Value("${api-key:secret-not-found}")
    private String apiKey;

    @Autowired
    private Environment environment;

    public static void main(String[] args) {
        SpringApplication.run(KeyVaultDemoApplication.class, args);
    }

    @GetMapping("/")
    public String home() {
        return "Key Vault Demo Application is running!<br>" +
               "Try: /secrets, /health, /env-info";
    }

    @GetMapping("/secrets")
    public String getSecrets() {
        return String.format(
            "<h2>Secrets from Key Vault:</h2>" +
            "Database Password: %s<br>" +
            "API Key: %s<br>",
            maskSecret(databasePassword),
            maskSecret(apiKey)
        );
    }

    @GetMapping("/health")
    public String health() {
        boolean secretsLoaded = !databasePassword.equals("secret-not-found") && 
                               !apiKey.equals("secret-not-found");
        return "<h2>Health Check:</h2>" +
               "Status: " + (secretsLoaded ? "✅ OK - Secrets loaded from Key Vault" : "❌ FAILED - Secrets not loaded");
    }

    @GetMapping("/env-info")
    public String envInfo() {
        String clientId = environment.getProperty("AZURE_CLIENT_ID", "not-set");
        String authority = environment.getProperty("AZURE_AUTHORITY_HOST", "not-set");
        String federatedTokenFile = environment.getProperty("AZURE_FEDERATED_TOKEN_FILE", "not-set");
        
        return String.format(
            "<h2>Environment Info:</h2>" +
            "AZURE_CLIENT_ID: %s<br>" +
            "AZURE_AUTHORITY_HOST: %s<br>" +
            "AZURE_FEDERATED_TOKEN_FILE: %s<br>",
            clientId, authority, federatedTokenFile
        );
    }

    private String maskSecret(String secret) {
        if (secret == null || secret.equals("secret-not-found") || secret.length() < 4) {
            return secret;
        }
        return secret.substring(0, 2) + "****" + secret.substring(secret.length() - 2);
    }
}
Step 8: Build and Deploy Application
bash
# Build the application
mvn clean package

# Create Dockerfile
cat > Dockerfile << EOF
FROM openjdk:17-jdk-slim
COPY target/keyvault-demo-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app.jar"]
EOF

# Build Docker image (replace with your registry)
docker build -t keyvault-demo:v1 .

# If using Azure Container Registry
# az acr login --name myregistry
# docker tag keyvault-demo:v1 myregistry.azurecr.io/keyvault-demo:v1
# docker push myregistry.azurecr.io/keyvault-demo:v1
Step 9: Create Kubernetes Deployment
Create deployment.yaml:

yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: keyvault-demo-app
  namespace: myapp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: keyvault-demo
  template:
    metadata:
      labels:
        app: keyvault-demo
        azure.workload.identity/use: "true"  # Important: Enable workload identity
    spec:
      serviceAccountName: workload-identity-sa  # Use the service account we created
      containers:
      - name: app
        image: keyvault-demo:v1  # Replace with your image
        ports:
        - containerPort: 8080
        env:
        - name: AZURE_CLIENT_ID
          value: "CLIENT_ID_VALUE_FROM_STEP_3"  # Replace with actual client ID
---
apiVersion: v1
kind: Service
metadata:
  name: keyvault-demo-service
  namespace: myapp
spec:
  selector:
    app: keyvault-demo
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
Step 10: Deploy and Test
bash
# Replace CLIENT_ID in deployment.yaml with actual value
sed -i "s/CLIENT_ID_VALUE_FROM_STEP_3/$IDENTITY_CLIENT_ID/g" deployment.yaml

# Deploy the application
kubectl apply -f deployment.yaml

# Check deployment status
kubectl get pods -n myapp
kubectl get services -n myapp

# Get logs to verify Key Vault connection
kubectl logs -l app=keyvault-demo -n myapp

# Get external IP and test
kubectl get service keyvault-demo-service -n myapp

# Test the endpoints (replace with actual external IP)
# curl http://EXTERNAL_IP/
# curl http://EXTERNAL_IP/health
# curl http://EXTERNAL_IP/secrets
Step 11: Troubleshooting Commands
bash
# Check workload identity status
kubectl describe pod -l app=keyvault-demo -n myapp

# Check service account annotations
kubectl get serviceaccount workload-identity-sa -n myapp -o yaml

# Check if secrets are being injected
kubectl exec -it $(kubectl get pods -l app=keyvault-demo -n myapp -o jsonpath='{.items[0].metadata.name}') -n myapp -- env | grep AZURE

# Check Key Vault permissions
az keyvault show --name $KEY_VAULT_NAME --query "properties.accessPolicies[?objectId=='$IDENTITY_PRINCIPAL_ID']"
This setup connects your existing AKS cluster to Azure Key Vault using Workload Identity (the modern, secure approach). The managed identity authenticates your pods to access Key Vault secrets automatically.








